{
  "version": 3,
  "file": "ngx-emoji.umd.min.js",
  "sources": [
    "ng://ngx-emoji/src/main/ngx-emoji.service.ts",
    "ng://ngx-emoji/src/main/ngx-emoji.component.ts",
    "ng://ngx-emoji/src/main/ngx-emoji-picker.component.ts",
    "ng://ngx-emoji/src/main/ngx-emoji.module.ts"
  ],
  "sourcesContent": [
    "import { Injectable } from '@angular/core';\nimport { Subject } from \"rxjs/Subject\";\nimport { NgxEmojiComponent } from \"./ngx-emoji.component\";\nimport { NgxEmojiModule } from \"./ngx-emoji.module\";\n\nexport interface NgxEmoji {\n    unified: string;\n    category: string;\n    bundle: number;\n}\n\n@Injectable()\nexport class NgxEmojiService {\n    protected static emojis: NgxEmoji[] = null;\n    public readonly onEmojiPicked: Subject<string> = new Subject<string>();\n    protected activeComponent: NgxEmojiComponent;\n\n    public static getEmojis(): NgxEmoji[] {\n        if (this.emojis === null) {\n            this.emojis = require('ngx-emoji/emojis.json');\n        }\n        return this.emojis;\n    }\n\n    public setActiveComponent(component: NgxEmojiComponent): void {\n        this.activeComponent = component;\n    }\n\n    public isActiveComponent(component: NgxEmojiComponent): boolean {\n        return component === this.activeComponent;\n    }\n\n    public loadEmoji(emoji: string): void {\n        let bundleId = this.getEmojiBundle(emoji);\n        if (bundleId !== null && !this.isCssBundleLoaded(bundleId)) {\n            this.loadCssBundle(bundleId);\n        }\n    }\n\n    protected getEmojiBundle(emoji: string): number {\n        for (let e of NgxEmojiService.getEmojis()) {\n            if (e.unified == emoji) {\n                return e.bundle;\n            }\n        }\n        return null;\n    }\n\n    public loadCssBundle(bundleId: number): void {\n        if (!this.isCssBundleLoaded(bundleId)) {\n            let id = 'ngx-emoji-bundle-' + bundleId;\n            let head = document.getElementsByTagName('head')[0];\n            let link = document.createElement('link');\n            link.id = id;\n            link.rel = 'stylesheet';\n            link.type = 'text/css';\n            link.href = NgxEmojiModule.getEmojiBundlesPath() + 'ngx-emoji-b' + bundleId + '.min.css';\n            link.media = 'all';\n            head.appendChild(link);\n        }\n    }\n\n    public isCssBundleLoaded(bundleId: number): boolean {\n        return (document.getElementById('ngx-emoji-bundle-' + bundleId)) ? true : false;\n    }\n\n    public recentPush(emoji: string): void {\n        let recent = this.getRecent();\n        if (recent.indexOf(emoji) > -1) {\n            return;\n        }\n        recent = [emoji].concat(recent)\n            .slice(0, NgxEmojiModule.getRecentMax());\n        window.localStorage.setItem('ngx-emoji-recent', recent.join(':'));\n    }\n\n    public getRecent(): string[] {\n        let recent = window.localStorage.getItem('ngx-emoji-recent');\n        if (!recent) {\n            return [];\n        }\n        return recent.split(':');\n    }\n\n}\n",
    "import { Component, OnDestroy, ElementRef, Input, Output, EventEmitter, HostListener } from '@angular/core';\nimport { NgxEmojiService } from \"./ngx-emoji.service\";\nimport { Subscription } from \"rxjs/Subscription\";\nimport { NgxEmojiPickerComponent } from \"./ngx-emoji-picker.component\";\n\nexport interface EnterOn {\n    shift?: boolean;\n    ctrl?: boolean;\n}\n\nexport interface SelectionRange {\n    start: number;\n    stop: number;\n}\n\nexport enum NgxEmojiEntityType {\n    Bold,\n    Italic,\n    Underline\n}\n\nexport interface NgxEmojiEntity {\n    type: NgxEmojiEntityType | string;\n    offset: number;\n    length: number;\n}\n\n@Component({\n    selector: 'ngx-emoji',\n    template: ''\n})\nexport class NgxEmojiComponent implements OnDestroy {\n    private _contenteditable: boolean = false;\n    private _enterOn: EnterOn = {\n        shift: false,\n        ctrl: false\n    };\n    private prevent: {\n        text: string, entities: NgxEmojiEntity[]\n    } = {\n        text: null, entities: null\n    };\n\n    protected emojiService: NgxEmojiService;\n    protected emojiServiceSubscription: Subscription = new Subscription();\n    protected lastSelectionRange: Range;\n    protected readonly allowedTags = ['b', 'i', 'u', 'strong', 'em'];\n\n    public constructor(\n        protected elRef: ElementRef,\n        globalEmojiService: NgxEmojiService\n    ) {\n        let component = this;\n        globalEmojiService.setActiveComponent(this);\n        this.emojiService = globalEmojiService;\n        let subscription = this.emojiService.onEmojiPicked.subscribe(function (emoji: string) {\n            if (globalEmojiService.isActiveComponent(component)) {\n                component.insertEmoji(emoji);\n            }\n        });\n        this.emojiServiceSubscription.add(subscription);\n        this.getNativeElement().appendChild(document.createTextNode(''));\n        let range = document.createRange();\n        range.setStart(this.getNativeElement().firstChild, 0);\n        this.lastSelectionRange = range;\n\n        /**\n         * see: onFocusout()\n         */\n        if (document.onselectionchange !== undefined) {\n            document.addEventListener('selectionchange', function () {\n                component.onSelectionchange();\n            });\n        }\n    }\n\n    public getNativeElement(): HTMLElement {\n        return this.elRef.nativeElement;\n    }\n\n    public ngOnDestroy(): void {\n        this.emojiServiceSubscription.unsubscribe();\n    }\n\n    public addEmojiService(service: NgxEmojiService): void {\n        service.setActiveComponent(this);\n        let component = this;\n        let subscription = service.onEmojiPicked.subscribe(function (emoji: string) {\n            if (service.isActiveComponent(component)) {\n                component.insertEmoji(emoji);\n            }\n        });\n        this.emojiServiceSubscription.add(subscription);\n    }\n\n    /**\n     * Emoji picker\n     */\n\n    @Input('picker')\n    protected set inputPicker(pickerComponent: NgxEmojiPickerComponent) {\n        this.emojiServiceSubscription.unsubscribe();\n        this.emojiServiceSubscription = new Subscription();\n        let service = new NgxEmojiService();\n        service.setActiveComponent(this);\n        this.emojiService = service;\n        pickerComponent.setEmojiService(service);\n        let component = this;\n        let subscription = this.emojiService.onEmojiPicked.subscribe(function (emoji: string) {\n            if (service.isActiveComponent(component)) {\n                component.insertEmoji(emoji);\n            }\n        });\n        this.emojiServiceSubscription.add(subscription);\n    }\n\n    /**\n     * Content editable\n     */\n\n    @Input('attr.contenteditable')\n    protected set attrContenteditable(editable: boolean) {\n        this.contenteditable = editable;\n    }\n\n    @Input('contenteditable')\n    public set contenteditable(editable: boolean) {\n        this._contenteditable = editable;\n        this.elRef.nativeElement.setAttribute('contenteditable', editable);\n        this.onContenteditable.emit(editable);\n    }\n\n    public get contenteditable(): boolean {\n        return this._contenteditable;\n    }\n\n    @Output('contenteditable')\n    public readonly onContenteditable: EventEmitter<boolean> = new EventEmitter<boolean>();\n\n    /**\n     * Enter on\n     */\n\n    @Input('enterOn')\n    public set enterOn(enterOn: EnterOn) {\n        this._enterOn = enterOn;\n        this.onEnterOn.emit(enterOn);\n    }\n\n    public get enterOn(): EnterOn {\n        return this._enterOn;\n    }\n\n    @Output('enterOn')\n    public readonly onEnterOn: EventEmitter<EnterOn> = new EventEmitter<EnterOn>();\n\n    public enterKeyIsEnter(): boolean {\n        return !this.enterKeyIsShiftEnter() && !this.enterKeyIsCtrlEnter();\n    }\n\n    public enterKeyIsCtrlEnter(): boolean {\n        return (this.enterOn.ctrl) ? true : false;\n    }\n\n    public enterKeyIsShiftEnter(): boolean {\n        return (this.enterOn.shift) ? true : false;\n    }\n\n    /**\n     * HTML\n     */\n\n    @Input('fullHtml')\n    public set fullHtml(html: string) {\n        this.getNativeElement().innerHTML = this.filterHtml(html, this.allowedTags)\n    }\n\n    public get fullHtml(): string {\n        let html = document.createElement('div');\n        html.innerHTML = this.getNativeElement().innerHTML;\n\n        for (let img of this.arrayOfNodeList(html.getElementsByTagName('img'))) {\n            if (!img.classList.contains('ngx-emoji')) {\n                continue;\n            }\n            let emoji = document.createElement('i');\n            emoji.className = img.className;\n            emoji.setAttribute('aria-hidden', 'true');\n            img.parentElement.insertBefore(emoji, img);\n            img.remove();\n        }\n\n        return html.innerHTML;\n    }\n\n    @Output('fullHtml')\n    public readonly onFullHtml: EventEmitter<string> = new EventEmitter<string>();\n\n    /**\n     * HTML wihout parahraphs\n     */\n\n    @Input('html')\n    public set html(html: string) {\n        this.getNativeElement().innerHTML = this.filterHtml(html, this.allowedTags)\n    }\n\n    public get html(): string {\n        return this.getHtml(this.getNativeElement());\n    }\n\n    protected getHtml(rootElement: HTMLElement): string {\n        let component = this;\n        let html = '';\n        let rf = function (nodes: NodeList): void {\n            for (let node of component.arrayOfNodeList(nodes)) {\n                let blockNode = component.isBlockNode(node);\n                if (component.isEmojiNode(node)) {\n                    html += component.emojiToSymbol(component.emojiFromNode(node));\n                } else if (node.hasChildNodes()) {\n                    if (!blockNode) {\n                        html += '<' + node.nodeName.toLowerCase() + '>';\n                    }\n                    rf(node.childNodes); // recursion...\n                    if (!blockNode) {\n                        html += '</' + node.nodeName.toLowerCase() + '>';\n                    }\n                } else {\n                    html += component.replaceAll(node.textContent, '\\n', '');\n                }\n                if (blockNode && !rootElement.lastChild.isSameNode(node)) {\n                    html += '\\n';\n                }\n                if (node.nodeName == 'BR'\n                    && node.parentNode.firstChild.nodeName != 'BR'\n                    && node.parentNode.childNodes.length != 1\n                    && rootElement.lastChild.lastChild\n                    && !rootElement.lastChild.lastChild.isSameNode(node)) {\n                    html += '\\n';\n                }\n                // hotfix: insert new line after non-block node\n                if (!blockNode\n                    && node.previousSibling\n                    && node.previousSibling.textContent.length > 0\n                    && node.nextSibling\n                    && component.isBlockNode(node.nextSibling)\n                    && node.parentNode.isSameNode(rootElement)) {\n                    html += '\\n';\n                }\n                // hotfix: insert new line after last emoji\n                if (component.isEmojiNode(node)\n                    && (node as HTMLElement).nextElementSibling\n                    && component.isBlockNode((node as HTMLElement).nextElementSibling)\n                    && node.nextSibling.textContent.length == 0) {\n                    html += '\\n';\n                }\n            }\n        };\n        rf(rootElement.childNodes);\n        html = this.replaceAll(html, '\\u00A0', ' ');\n        html = this.replaceAll(html, '&nbsp;', ' ');\n        return this.filterHtml(html, this.allowedTags);\n    }\n\n    @Output('html')\n    public readonly onHtml: EventEmitter<string> = new EventEmitter<string>();\n\n    /**\n     * Text\n     */\n\n    @Input('text')\n    public set text(text: string) {\n        if (!this.contenteditable && text == this.prevent.text) {\n            return;\n        }\n        this.prevent.text = text;\n\n        let component = this;\n        text = this.filterHtml(text);\n        text = this.replaceAll(text, '\\u00A0', ' ');\n        text = this.replaceAll(text, '  ', '&nbsp;&nbsp;');\n        text = this.replaceSymbolsToEmojis(text);\n\n        let paragraphs = text.split('\\n');\n        text = '';\n        for (let paragraph of paragraphs) {\n            if (paragraph.length == 0) {\n                paragraph = '<br>';\n            }\n            if (paragraph == ' ') {\n                paragraph = '&nbsp;';\n            }\n            text += '<div>' + paragraph + '</div>';\n        }\n        this.getNativeElement().innerHTML = text;\n        if (this.getNativeElement().childNodes.length == 0) {\n            this.getNativeElement().appendChild(document.createTextNode(''));\n        }\n        let range = document.createRange();\n        let lastChild = this.getNativeElement().lastChild;\n        while (lastChild.hasChildNodes()) {\n            lastChild = lastChild.lastChild;\n        }\n        range.setStart(lastChild, lastChild.textContent.length);\n        this.lastSelectionRange = range;\n    }\n\n    public get text(): string {\n        return this.filterHtml(this.html);\n    }\n\n    @Output('text')\n    public readonly onText: EventEmitter<string> = new EventEmitter<string>();\n\n    /**\n     * Entities\n     */\n\n    protected normalizeEntityType(type: any): NgxEmojiEntityType {\n        if (typeof type == 'string') {\n            type = type.toLowerCase();\n        }\n        switch (type) {\n            case 'bold':\n            case NgxEmojiEntityType.Bold:\n                return NgxEmojiEntityType.Bold;\n            case 'italic':\n            case NgxEmojiEntityType.Italic:\n                return NgxEmojiEntityType.Italic;\n            case 'underline':\n            case NgxEmojiEntityType.Underline:\n                return NgxEmojiEntityType.Underline;\n            default:\n                return null;\n        }\n    }\n\n    @Input('entities')\n    public set entities(entities: NgxEmojiEntity[]) {\n        if (!this.contenteditable && JSON.stringify(entities) == JSON.stringify(this.prevent.entities)) {\n            return;\n        }\n        this.prevent.entities = entities;\n\n        let component = this;\n        let nativeElement = this.getNativeElement();\n        let selection = window.getSelection();\n        let previousRange = (selection.rangeCount) ? selection.getRangeAt(0) : null;\n        let previousContenteditableState = this.contenteditable;\n        if (!Array.isArray(entities)) {\n            entities = [];\n        }\n        entities = entities.map(function (entity) {\n            return {\n                offset: entity.offset,\n                length: entity.length,\n                type: component.normalizeEntityType(entity.type)\n            };\n        }).filter(function (entity) {\n            return entity.type !== null;\n        });\n\n        // Clear html formatting\n        let text = this.text;\n        this.text = '';\n        this.text = text;\n\n        // Enable contenteditable for exec commands\n        this.contenteditable = true;\n\n        let endFounded = false;\n        for (let entity of entities) {\n            let range = document.createRange();\n            let offset = 0;\n            let rf = function (nodes: NodeList) {\n                for (let i = 0; i < nodes.length; i++) {\n                    let node = nodes.item(i);\n                    if (component.isEmojiNode(node)) {\n                        let textLength = component.emojiToSymbol(component.emojiFromNode(node)).length;\n                        if (offset <= entity.offset && offset + textLength >= entity.offset) {\n                            range.setStartBefore(node);\n                        }\n                        if (offset <= entity.offset + entity.length && offset + textLength >= entity.offset + entity.length) {\n                            range.setEndAfter(node);\n                            endFounded = true;\n                        }\n                        offset += textLength;\n                    } else {\n                        if (node.hasChildNodes()) {\n                            rf(node.childNodes); // recursion\n                        } else if (node.nodeName != 'BR') {\n                            let textLength = node.textContent.length;\n                            if (offset <= entity.offset && offset + textLength >= entity.offset) {\n                                range.setStart(node, entity.offset - offset);\n                            }\n                            if (offset <= entity.offset + entity.length && offset + textLength >= entity.offset + entity.length) {\n                                range.setEnd(node, entity.offset + entity.length - offset);\n                                endFounded = true;\n                            }\n                            offset += textLength;\n                        }\n                        if (component.isBlockNode(node)) {\n                            offset++;\n                            if (entity.offset + entity.length == offset) {\n                                range.setEndAfter(node.lastChild);\n                                endFounded = true;\n                            }\n                        }\n                    }\n                }\n            };\n            rf(nativeElement.childNodes);\n            if (!endFounded) {\n                range.setEndAfter(nativeElement.lastChild);\n            }\n            selection.removeAllRanges();\n            selection.addRange(range);\n            this.formatText(entity.type as NgxEmojiEntityType);\n        }\n\n        // Restore previous state\n        selection.removeAllRanges();\n        if (previousRange) {\n            selection.addRange(previousRange);\n        }\n        this.contenteditable = previousContenteditableState;\n    }\n\n    public get entities(): NgxEmojiEntity[] {\n        let component = this;\n        let entities: NgxEmojiEntity[] = [];\n        let rf = function (nodes: NodeList, offset: number): void {\n            for (let node of component.arrayOfNodeList(nodes)) {\n                if (node.textContent.trim().length > 0) {\n                    let nodeName = node.nodeName.toUpperCase();\n                    if (nodeName == 'B' || nodeName == 'STRONG') {\n                        entities.push({\n                            type: NgxEmojiEntityType[NgxEmojiEntityType.Bold].toLowerCase(),\n                            offset: offset,\n                            length: node.textContent.length\n                        });\n                    }\n                    if (nodeName == 'I' || nodeName == 'EM') {\n                        entities.push({\n                            type: NgxEmojiEntityType[NgxEmojiEntityType.Italic].toLowerCase(),\n                            offset: offset,\n                            length: node.textContent.length\n                        });\n                    }\n                    if (nodeName == 'U') {\n                        entities.push({\n                            type: NgxEmojiEntityType[NgxEmojiEntityType.Underline].toLowerCase(),\n                            offset: offset,\n                            length: node.textContent.length\n                        });\n                    }\n                }\n                rf(node.childNodes, offset);\n                offset += node.textContent.length;\n            }\n        };\n        let div = document.createElement('div');\n        div.innerHTML = this.html;\n        rf(div.childNodes, 0);\n        div.remove();\n        return entities;\n    }\n\n    @Output('entities')\n    public readonly onEntities: EventEmitter<NgxEmojiEntity[]> = new EventEmitter<NgxEmojiEntity[]>();\n\n    /**\n     * Enter events\n     */\n\n    @Output('enter')\n    public readonly onEnter: EventEmitter<void> = new EventEmitter<void>();\n\n    @HostListener(\"keydown.enter\", ['$event'])\n    protected onKeydownEnter(event: KeyboardEvent): void {\n        if (!this.contenteditable) {\n            return;\n        }\n        event.preventDefault();\n        if (this.enterKeyIsEnter()) {\n            this.emitEnter();\n        } else {\n            this.insertNewLine();\n        }\n    }\n\n    @HostListener(\"keydown.control.enter\", ['$event'])\n    protected onKeydownControlEnter(event: KeyboardEvent): void {\n        if (!this.contenteditable) {\n            return;\n        }\n        event.preventDefault();\n        if (this.enterKeyIsCtrlEnter()) {\n            this.emitEnter();\n        } else {\n            this.insertNewLine();\n        }\n    }\n\n    @HostListener(\"keydown.shift.enter\", ['$event'])\n    protected onKeydownShiftEnter(event: KeyboardEvent): void {\n        if (!this.contenteditable) {\n            return;\n        }\n        event.preventDefault();\n        if (this.enterKeyIsShiftEnter()) {\n            this.emitEnter();\n        }\n    }\n\n    protected emitEnter(): void {\n        this.onText.emit(this.text);\n        this.onEntities.emit(this.entities);\n        this.onFullHtml.emit(this.fullHtml);\n        this.onHtml.emit(this.html);\n        this.onEnter.emit();\n    }\n\n    /**\n     * Keyboard events\n     */\n\n    @HostListener(\"keydown\", ['$event'])\n    protected onKeydown(event: KeyboardEvent): void {\n        if (event.ctrlKey && event.keyCode == 66) {\n            event.preventDefault();\n            this.formatText(NgxEmojiEntityType.Bold);\n        }\n        if (event.ctrlKey && event.keyCode == 73) {\n            event.preventDefault();\n            this.formatText(NgxEmojiEntityType.Italic);\n        }\n        if (event.ctrlKey && event.keyCode == 85) {\n            event.preventDefault();\n            this.formatText(NgxEmojiEntityType.Underline);\n        }\n    }\n\n    /**\n     * Focus events\n     */\n\n    @HostListener(\"focus\")\n    protected onFocus(): void {\n        this.emojiService.setActiveComponent(this);\n    }\n\n    /**\n     * Get selection before blur don't work in Firefox.\n     * Use hotfix with onSelectionchange()\n     * This is fallback\n     */\n    @HostListener(\"focusout\")\n    protected onFocusout(): void {\n        if (document.onselectionchange === undefined) {\n            this.lastSelectionRange = window.getSelection().getRangeAt(0);\n        }\n    }\n\n    protected onSelectionchange() {\n        let selection = window.getSelection();\n        if (selection.containsNode(this.getNativeElement(), true)) {\n            this.lastSelectionRange = selection.getRangeAt(0);\n        }\n    }\n\n    /**\n     * Clipboard events\n     */\n\n    @HostListener(\"paste\", ['$event'])\n    protected onPaste(event: ClipboardEvent): void {\n        event.preventDefault();\n        let html = '';\n        if (event.clipboardData.types.indexOf('text/html') > -1) {\n            html = event.clipboardData.getData('text/html');\n        } else if (event.clipboardData.types.indexOf('text/plain') > -1) {\n            html = event.clipboardData.getData('text/plain');\n        }\n        html = this.filterHtml(html, this.allowedTags);\n        html = this.replaceSymbolsToEmojis(html);\n        this.execCommand('insertHTML', html);\n    }\n\n    @HostListener(\"copy\", ['$event'])\n    protected onCopy(event: ClipboardEvent): void {\n        let previousRange = window.getSelection().getRangeAt(0);\n        if (previousRange.collapsed) {\n            return;\n        }\n        event.preventDefault();\n        let content: DocumentFragment = window.getSelection().getRangeAt(0).cloneContents();\n        let div = document.createElement('div');\n        div.appendChild(content);\n        div.innerHTML = this.getHtml(div);\n        // Copy HTML hack\n        document.getElementsByTagName('body')[0].appendChild(div);\n        let range = document.createRange();\n        range.setStartBefore(div.firstChild);\n        range.setEndAfter(div.lastChild);\n        let selection = window.getSelection();\n        selection.removeAllRanges();\n        selection.addRange(range);\n        this.execCommand('copy');\n        div.remove();\n        selection.removeAllRanges();\n        selection.addRange(previousRange);\n    }\n\n    @HostListener(\"cut\", ['$event'])\n    protected onCut(event: ClipboardEvent): void {\n        this.onCopy(event);\n        this.execCommand('delete');\n    }\n\n    /**\n     * Click events\n     */\n\n    @HostListener(\"click\", ['$event'])\n    protected onClick(event: MouseEvent): void {\n        if (!this.contenteditable) {\n            return;\n        }\n        if (this.isEmojiNode(event.toElement)) {\n            let range = document.createRange();\n            range.setStartBefore(event.toElement);\n            let selection = window.getSelection();\n            selection.removeAllRanges();\n            selection.addRange(range);\n        }\n    }\n\n    /**\n     * Internal\n     */\n\n    protected arrayOfNodeList<T extends Node>(list: NodeListOf<T>): T[] {\n        let result: T[] = [];\n        for (let i = 0; i < list.length; i++) {\n            result.push(list.item(i))\n        }\n        return result;\n    }\n\n    protected isBlockNode(node: Node): boolean {\n        if (!(node instanceof HTMLElement)) {\n            return false;\n        }\n        if (node instanceof HTMLDivElement) {\n            return true;\n        }\n        return window.getComputedStyle(node, '').display == 'block';\n    }\n\n    protected isEmojiNode(node: Node): boolean {\n        if (!(node instanceof HTMLElement)) {\n            return false;\n        }\n        return node.classList.contains('ngx-emoji');\n    }\n\n    protected emojiFromNode(node: Node): string {\n        if (!this.isEmojiNode(node)) {\n            return null;\n        }\n        let classList = (node as HTMLElement).classList;\n        let emoji = null;\n        for (let i = 0; i < classList.length; i++) {\n            if (classList.item(i).substr(0, 10) == 'ngx-emoji-') {\n                emoji = classList.item(i).substr(10);\n                break;\n            }\n        }\n        return emoji;\n    }\n\n    protected replaceSymbolsToEmojis(text: string): string {\n        let component = this;\n        text = text.replace(this.getEmojiRegex(), function (match) {\n            return component.createEmojiImg(component.emojiFromSymbol(match));\n        });\n        text = this.replaceAll(text, '\\uFE0F', ''); // remove variation selector\n        return text;\n    }\n\n    /**\n     * String replace all implementation\n     *\n     * See: https://stackoverflow.com/a/1144788/1617101\n     */\n    protected replaceAll(str: string, find: string, replace: string): string {\n        find = find.replace(/([.*+?^=!:${}()|\\[\\]\\/\\\\])/g, \"\\\\$1\");\n        return str.replace(new RegExp(find, 'g'), replace);\n    }\n\n    protected execCommand(command: string, value?: any): boolean {\n        return document.execCommand(command, false, value);\n    }\n\n    protected insertNewLine(): void {\n        this.execCommand('insertParagraph');\n    }\n\n    protected createEmojiImg(emoji: string): string {\n        this.emojiService.loadEmoji(emoji);\n        return '<img class=\"ngx-emoji ngx-emoji-' + emoji + '\" ' +\n            'aria-hidden=\"true\" ' +\n            'alt=\"' + this.emojiToSymbol(emoji) + '\" ' +\n            'src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=\">';\n    }\n\n    protected emojiToSymbol(emoji: string): string {\n        emoji = emoji.trim();\n        if (emoji.length == 0) {\n            return '�';\n        }\n        let emojiCodes = emoji.split('-').map(function (value) {\n            return parseInt('0x' + value, 16);\n        });\n        try {\n            emoji = String.fromCodePoint.apply(String, emojiCodes);\n        } catch (error) {\n            console.warn('Convert emoji ' + emoji + ' error: ' + error.message);\n            emoji = '�';\n        }\n        return emoji;\n    }\n\n    protected emojiFromSymbol(symbol: string): string {\n        let codes: string[] = [];\n        for (let i = 0; i < symbol.length; i++) {\n            codes.push(symbol.codePointAt(i).toString(16));\n        }\n        codes = codes\n            .filter(function (code: string) {\n                let p = parseInt(code, 16);\n                return !(p >= 0xD800 && p <= 0xDFFF);\n            })\n            .map(function (code: string) {\n                let pad = '0000';\n                return pad.substring(0, pad.length - code.length) + code;\n            });\n        return codes.join('-').toUpperCase();\n    }\n\n    protected insertEmoji(emoji: string): void {\n        if (!this.contenteditable) {\n            return;\n        }\n        let selection = window.getSelection();\n        selection.removeAllRanges();\n        selection.addRange(this.lastSelectionRange);\n        this.execCommand(\n            'insertHTML',\n            this.createEmojiImg(emoji)\n        );\n        this.emojiService.recentPush(emoji);\n    }\n\n    protected filterHtml(html: string, allowTags: string[] = []): string {\n        let component = this;\n        allowTags = allowTags.map(function (value) {\n            return value.toUpperCase();\n        });\n        let tmp = document.createElement(\"div\");\n        tmp.innerHTML = html;\n        html = '';\n        let rf = function (nodes: NodeList): void {\n            for (let node of component.arrayOfNodeList(nodes)) {\n                if (node.nodeType == node.ELEMENT_NODE) {\n                    if (allowTags.indexOf(node.nodeName) > -1) {\n                        html += '<' + node.nodeName.toLowerCase() + '>';\n                        rf(node.childNodes);\n                        html += '</' + node.nodeName.toLowerCase() + '>';\n                    } else {\n                        rf(node.childNodes);\n                    }\n                } else {\n                    html += node.textContent;\n                }\n            }\n        };\n        rf(tmp.childNodes);\n        tmp.remove();\n        return html;\n    }\n\n    protected formatText(type: NgxEmojiEntityType): void {\n        switch (type) {\n            case NgxEmojiEntityType.Bold:\n                this.execCommand('bold');\n                break;\n            case NgxEmojiEntityType.Italic:\n                this.execCommand('italic');\n                break;\n            case NgxEmojiEntityType.Underline:\n                this.execCommand('underline');\n                break;\n        }\n    }\n\n    /**\n     * See: https://stackoverflow.com/a/41164587/1617101\n     */\n    protected getEmojiRegex(): RegExp {\n        return /(?:[\\u2700-\\u27bf]|(?:\\ud83c[\\udde6-\\uddff]){2}|[\\ud800-\\udbff][\\udc00-\\udfff]|[\\u0023-\\u0039]\\ufe0f?\\u20e3|\\u3299|\\u3297|\\u303d|\\u3030|\\u24c2|\\ud83c[\\udd70-\\udd71]|\\ud83c[\\udd7e-\\udd7f]|\\ud83c\\udd8e|\\ud83c[\\udd91-\\udd9a]|\\ud83c[\\udde6-\\uddff]|[\\ud83c[\\ude01\\uddff]|\\ud83c[\\ude01-\\ude02]|\\ud83c\\ude1a|\\ud83c\\ude2f|[\\ud83c[\\ude32\\ude02]|\\ud83c\\ude1a|\\ud83c\\ude2f|\\ud83c[\\ude32-\\ude3a]|[\\ud83c[\\ude50\\ude3a]|\\ud83c[\\ude50-\\ude51]|\\u203c|\\u2049|[\\u25aa-\\u25ab]|\\u25b6|\\u25c0|[\\u25fb-\\u25fe]|\\u00a9|\\u00ae|\\u2122|\\u2139|\\ud83c\\udc04|[\\u2600-\\u26FF]|\\u2b05|\\u2b06|\\u2b07|\\u2b1b|\\u2b1c|\\u2b50|\\u2b55|\\u231a|\\u231b|\\u2328|\\u23cf|[\\u23e9-\\u23f3]|[\\u23f8-\\u23fa]|\\ud83c\\udccf|\\u2934|\\u2935|[\\u2190-\\u21ff])/g;\n    }\n\n}\n",
    "import { Component, OnInit, Input } from '@angular/core';\nimport { NgxEmoji, NgxEmojiService } from \"./ngx-emoji.service\";\nimport { NgxEmojiComponent } from \"./ngx-emoji.component\";\n\nexport interface NgxEmojiPickerCategories {\n    [key: string]: NgxEmoji[];\n}\n\n@Component({\n    selector: 'ngx-emoji-picker',\n    template: `<ul>\n    <li *ngFor=\"let category of Object.keys(categories)\"\n        (click)=\"selectCategory(category)\">{{ category }}</li>\n</ul>\n\n<i *ngFor=\"let emoji of getEmojis()\"\n   [class]=\"'ngx-emoji ngx-emoji-' + emoji.unified\"\n   aria-hidden=\"true\"\n   (click)=\"emojiPicked(emoji.unified)\"\n></i>\n`\n})\nexport class NgxEmojiPickerComponent implements OnInit {\n    private Object: Object = Object;\n    protected categories: NgxEmojiPickerCategories = {Recent: []};\n    protected currentCategory: string = 'Recent';\n\n    public constructor(\n        protected emojiService: NgxEmojiService\n    ) {\n    }\n\n    public ngOnInit(): void {\n        for (let emoji of NgxEmojiService.getEmojis()) {\n            if (this.categories[emoji.category] == undefined) {\n                this.categories[emoji.category] = null;\n            }\n        }\n    }\n\n    public setEmojiService(service: NgxEmojiService): void {\n        this.emojiService = service;\n    }\n\n    @Input('for')\n    protected set inputFor(emojiComponent: NgxEmojiComponent) {\n        this.emojiService = new NgxEmojiService();\n        emojiComponent.addEmojiService(this.emojiService);\n    }\n\n    protected emojiPicked(emoji: string): void {\n        this.emojiService.onEmojiPicked.next(emoji);\n    }\n\n    public selectCategory(category: string): void {\n        this.currentCategory = category;\n    }\n\n    protected loadCategory(category: string): void {\n        let emojis = NgxEmojiService.getEmojis().filter(function (emoji) {\n            return emoji.category == category;\n        });\n        for (let emoji of emojis) {\n            this.emojiService.loadEmoji(emoji.unified);\n        }\n        this.categories[category] = emojis;\n    }\n\n    protected getEmojis(): NgxEmoji[] {\n        let category = this.currentCategory;\n        if (category == 'Recent') {\n            let recent: NgxEmoji[] = [];\n            for (let emoji of this.emojiService.getRecent()) {\n                for (let e of NgxEmojiService.getEmojis()) {\n                    if (e.unified == emoji) {\n                        recent.push(e);\n                        this.emojiService.loadEmoji(e.unified);\n                        break;\n                    }\n                }\n            }\n            return recent;\n        } else {\n            if (this.categories[category] == null) {\n                this.loadCategory(category);\n            }\n            return this.categories[category];\n        }\n    }\n\n}\n",
    "import { NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { NgxEmojiPickerComponent } from './ngx-emoji-picker.component';\nimport { NgxEmojiComponent } from './ngx-emoji.component';\nimport { NgxEmojiService } from './ngx-emoji.service';\nimport 'ngx-emoji/ngx-emoji.min.css';\n\n@NgModule({\n    imports: [\n        CommonModule\n    ],\n    declarations: [\n        NgxEmojiPickerComponent, NgxEmojiComponent\n    ],\n    providers: [\n        NgxEmojiService\n    ],\n    exports: [\n        NgxEmojiPickerComponent, NgxEmojiComponent\n    ]\n})\nexport class NgxEmojiModule {\n    protected static emojiBundlesPath: string = 'https://cdn.rawgit.com/arswarog/ngx-emoji/build/ngx-emoji-assets/';\n    protected static recentMax: number = 20;\n\n    public static setEmojiBundlesPath(path: string): void {\n        NgxEmojiModule.emojiBundlesPath = path;\n    }\n\n    public static getEmojiBundlesPath(): string {\n        return NgxEmojiModule.emojiBundlesPath;\n    }\n\n    public static setRecentMax(max: number): void {\n        NgxEmojiModule.recentMax = max;\n    }\n\n    public static getRecentMax(): number {\n        return NgxEmojiModule.recentMax;\n    }\n\n}\n"
  ],
  "names": [
    "NgxEmojiService",
    "this",
    "onEmojiPicked",
    "Subject$1",
    "emojis",
    "require",
    "prototype",
    "setActiveComponent",
    "component",
    "isActiveComponent",
    "activeComponent",
    "bundleId",
    "isCssBundleLoaded",
    "loadCssBundle",
    "e",
    "unified",
    "emoji",
    "bundle",
    "e_1_1",
    "e_1",
    "error",
    "_b",
    "done",
    "_c",
    "_a",
    "return",
    "call",
    "link",
    "id",
    "rel",
    "type",
    "href",
    "NgxEmojiModule",
    "getEmojiBundlesPath",
    "media",
    "head",
    "appendChild",
    "document",
    "getElementById",
    "recent",
    "getRecent",
    "NgxEmojiEntityType",
    "Bold",
    "Italic",
    "Underline",
    "NgxEmojiComponent",
    "elRef",
    "globalEmojiService",
    "ctrl",
    "prevent",
    "text",
    "entities",
    "emojiServiceSubscription",
    "Subscription$1",
    "allowedTags",
    "onContenteditable",
    "EventEmitter",
    "onEnterOn",
    "onFullHtml",
    "onHtml",
    "onText",
    "onEntities",
    "emojiService",
    "subscription",
    "subscribe",
    "getNativeElement",
    "createTextNode",
    "range",
    "createRange",
    "onselectionchange",
    "undefined",
    "nativeElement",
    "addEmojiService",
    "service",
    "insertEmoji",
    "add",
    "Object",
    "defineProperty",
    "enumerable",
    "configurable",
    "get",
    "enterKeyIsEnter",
    "enterKeyIsShiftEnter",
    "enterKeyIsCtrlEnter",
    "enterOn",
    "e_2",
    "html",
    "createElement",
    "innerHTML",
    "className",
    "img",
    "setAttribute",
    "parentElement",
    "insertBefore",
    "remove",
    "e_2_1",
    "set",
    "filterHtml",
    "getHtml",
    "rootElement",
    "isEmojiNode",
    "node",
    "emojiToSymbol",
    "emojiFromNode",
    "hasChildNodes",
    "blockNode",
    "nodeName",
    "toLowerCase",
    "rf",
    "childNodes",
    "replaceAll",
    "textContent",
    "lastChild",
    "isSameNode",
    "parentNode",
    "firstChild",
    "length",
    "previousSibling",
    "nextSibling",
    "isBlockNode",
    "nextElementSibling",
    "e_3_1",
    "e_3",
    "contenteditable",
    "paragraphs",
    "replaceSymbolsToEmojis",
    "split",
    "paragraphs_1",
    "__values",
    "paragraphs_1_1",
    "next",
    "paragraph",
    "value",
    "e_4_1",
    "e_4",
    "setStart",
    "lastSelectionRange",
    "normalizeEntityType",
    "nodes",
    "offset",
    "arrayOfNodeList",
    "trim",
    "push",
    "e_5_1",
    "e_5",
    "div",
    "JSON",
    "stringify",
    "selection",
    "window",
    "getSelection",
    "previousRange",
    "getRangeAt",
    "previousContenteditableState",
    "Array",
    "isArray",
    "entity",
    "filter",
    "i",
    "item",
    "textLength",
    "setStartBefore",
    "endFounded",
    "setEndAfter",
    "removeAllRanges",
    "addRange",
    "e_6_1",
    "e_6",
    "onKeydownEnter",
    "event",
    "preventDefault",
    "emitEnter",
    "onKeydownControlEnter",
    "insertNewLine",
    "onKeydownShiftEnter",
    "emit",
    "onEnter",
    "onKeydown",
    "ctrlKey",
    "keyCode",
    "formatText",
    "onFocusout",
    "onSelectionchange",
    "containsNode",
    "onPaste",
    "clipboardData",
    "types",
    "indexOf",
    "getData",
    "execCommand",
    "onCopy",
    "collapsed",
    "content",
    "cloneContents",
    "onCut",
    "toElement",
    "list",
    "result",
    "getComputedStyle",
    "display",
    "HTMLElement",
    "classList",
    "contains",
    "substr",
    "replace",
    "getEmojiRegex",
    "match",
    "createEmojiImg",
    "emojiFromSymbol",
    "str",
    "find",
    "RegExp",
    "command",
    "loadEmoji",
    "emojiCodes",
    "map",
    "parseInt",
    "console",
    "warn",
    "message",
    "symbol",
    "codes",
    "codePointAt",
    "toString",
    "code",
    "p",
    "substring",
    "join",
    "toUpperCase",
    "allowTags",
    "tmp",
    "e_7",
    "decorators",
    "Component",
    "args",
    "selector",
    "template",
    "ctorParameters",
    "ElementRef",
    "propDecorators",
    "inputPicker",
    "Input",
    "attrContenteditable",
    "Output",
    "fullHtml",
    "HostListener",
    "onClick",
    "NgxEmojiPickerComponent",
    "categories",
    "category",
    "e_8_1",
    "e_8",
    "setEmojiService"
  ],
  "mappings": "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"
}
